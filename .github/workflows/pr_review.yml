name: PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths-ignore:
      - 'docs/releases/**'
  workflow_dispatch:

concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  # Reuse CI results instead of duplicating checks
  ci-status-check:
    runs-on: ubuntu-latest
    outputs:
      ci_status: ${{ steps.check-ci.outputs.status }}
    continue-on-error: true  # Allow this job to fail without stopping the workflow
    steps:
      - name: Check CI Status
        id: check-ci
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            const pull = await github.rest.pulls.get({
              owner, repo, pull_number: number
            });
            const sha = pull.data.head.sha;
            const checkRuns = await github.rest.checks.listForRef({
              owner, repo, ref: sha
            });
            const relevantWorkflows = checkRuns.data.check_runs.filter(
              run =>
                (run.name.includes('Tests') ||
                 run.name.includes('Linters') ||
                 run.name.includes('flake8') ||
                 run.name.includes('isort') ||
                 run.name.includes('black') ||
                 run.name.includes('JavaScript tests')) &&
                run.status === 'completed'
            );
            if (relevantWorkflows.length === 0) {
              core.setOutput('status', 'pending');
              return { status: 'pending' };
            }
            const allPassing = relevantWorkflows.every(
              run => run.conclusion === 'success'
            );
            const status = allPassing ? 'success' : 'failure';
            core.setOutput('status', status);
            return { status };

  # Test coverage check - simplified to focus only on Python files
  test-coverage:
    runs-on: ubuntu-latest
    outputs:
      has_tests: ${{ steps.check-tests.outputs.has_tests }}
    continue-on-error: true  # Allow this job to fail without stopping the workflow
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Check for test files
        id: check-tests
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            const files = await github.rest.pulls.listFiles({
              owner, repo, pull_number: number
            });
            const pythonFiles = files.data.filter(
              file => file.filename.endsWith('.py')
            ).filter(
              file =>
                !file.filename.includes('/tests/') &&
                !file.filename.includes('test_')
            );
            const testFiles = files.data.filter(
              file => file.filename.endsWith('.py')
            ).filter(
              file =>
                file.filename.includes('/tests/') ||
                file.filename.includes('test_')
            );
            const hasTests = testFiles.length > 0 ||
                             pythonFiles.length === 0;
            core.setOutput('has_tests', hasTests ? 'true' : 'false');
            if (pythonFiles.length > 0 && !hasTests) {
              await github.rest.issues.createComment({
                owner, repo, issue_number: number,
                body: "⚠️ **Test Coverage Check**\n" +
                      "This PR modifies Python code but doesn't appear " +
                      "to include any test files. Please consider adding tests " +
                      "to cover your changes."
              });
            }
            return { has_tests: hasTests };

  # Documentation checks - combined into a single job for efficiency
  documentation-checks:
    runs-on: ubuntu-latest
    outputs:
      has_version_notes: ${{ steps.check-version-notes.outputs.has_version_notes }}
      doc_checks_valid: ${{ steps.summarize-doc-checks.outputs.all_valid }}
    continue-on-error: true  # Allow this job to fail without stopping the workflow
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"
      - name: Check for version notes
        id: check-version-notes
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const { owner, repo, number } = context.issue;
            const files = await github.rest.pulls.listFiles({
              owner, repo, pull_number: number
            });
            const djangoFiles = files.data.filter(
              file => file.filename.endsWith(".py")
            ).filter(
              file =>
                file.filename.startsWith("django/") &&
                !file.filename.includes("tests/")
            );
            let needsVersionNotes = djangoFiles.length > 0;
            let hasVersionNotes = false;
            if (needsVersionNotes) {
              for (const file of djangoFiles.concat(
                files.data.filter(
                  file =>
                    file.filename.endsWith(".txt") ||
                    file.filename.endsWith(".rst")
                ).filter(
                  file => file.filename.startsWith("docs/")
                )
              )) {
                try {
                  if (fs.existsSync(file.filename)) {
                    const fileContent = fs.readFileSync(
                      file.filename, "utf8"
                    );
                    if (
                      fileContent.includes(".. versionadded::") ||
                      fileContent.includes(".. versionchanged::")
                    ) {
                      hasVersionNotes = true;
                      break;
                    }
                  }
                } catch (error) {
                  console.error(`Error reading file ${file.filename}: ${error}`);
                }
              }
            }
            core.setOutput("has_version_notes", 
              hasVersionNotes ? "true" : "false");
            if (needsVersionNotes && !hasVersionNotes) {
              await github.rest.issues.createComment({
                owner, repo, issue_number: number,
                body: "⚠️ **Version Notes Check**\n" +
                      "This PR modifies Django core files but doesn't appear " +
                      "to include version notes (`.. versionadded::` or " +
                      "`.. versionchanged::`). Please add appropriate version " +
                      "notes in docstrings or documentation files."
              });
            }
            return { has_version_notes: hasVersionNotes };

  # PR summary and label management
  pr-review-summary:
    runs-on: ubuntu-latest
    needs:
      - ci-status-check
      - test-coverage
      - documentation-checks
    steps:
      - name: Generate PR Review Summary
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            const pull = await github.rest.pulls.get({
              owner, repo, pull_number: number
            });
            const ciStatus = "${{ needs.ci-status-check.result }}";
            const hasTests = "${{ needs.test-coverage.result }}";